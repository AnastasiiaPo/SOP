//Cwiczenie 1
#include <iostream>

auto main() -> int
{
	int* ap = reinterpret_cast<int*>(0xdeadbeef);
        std::cout << ap << "\n";
	std::cout << *ap << "\n";

	return 0;    
}

//Cwiczenie 2
#include <iostream>
#include <sys/types.h>
#include <unistd.h>

auto main() -> int 
{
	auto x = fork();
	if(x == 0)
       	{
		std::cout << "ppid: " << getppid() << "\n";
	} else {
		std::cout << "inny: " << x << "\n";
	}

	return 0;
}

//Cwiczenie 3
#include <iostream>
#include <unistd.h>

auto main() -> int
{ 
	char *args[] = {"ls", (char *)0};
	char *env[] = {"HOME=/usr/home", "LOGNAME=home", (char*)0 };
  	auto ret = execve ("/bin/ls", args, env);

	if (ret == -1)
	{
		perror("Could not execve");
	}
	return 1;
}

//Cwiczenie 4
#include <iostream>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

auto handler_fork_sleep(int signal_number) -> void 
{
	auto x = fork();

	if (x == 0)
	{
	sleep(10);
	}
}


auto main() -> int
{
	signal(SIGCHLD, handler_fork_sleep);
        waitpid(-1, NULL, 0);

	return 0;
}

//Cwiczenie 7
#include <iostream>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

auto handler_sigusr1(int signum) -> void
{
	char msg[] = "Signal ?? SIGUSR1\n";
	msg[7] = (signum / 10) + '0';
	msg[8] = (signum % 10) + '0';
	auto ret = write(2, msg, sizeof(msg) - 1);
	std::cout << ret;
}
auto main() -> int
{
	struct sigaction action;

	action.sa_flags = 0;
	action.sa_handler = handler_sigusr1;
	sigemptyset(&action.sa_mask);

	sigaction(SIGUSR1, &action, NULL);

	return 0;
}
